{
  "entities": {
    "Party": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Party",
      "type": "object",
      "description": "Represents a single party event created by a user.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Party entity."
        },
        "name": {
          "type": "string",
          "description": "The name of the party event."
        },
        "description": {
          "type": "string",
          "description": "A detailed description of the party."
        },
        "dateTime": {
          "type": "string",
          "description": "The date and time when the party is scheduled to occur.",
          "format": "date-time"
        },
        "ownerId": {
          "type": "string",
          "description": "The Firebase UID of the user who created the party (the host)."
        },
        "inviteCode": {
          "type": "string",
          "description": "A unique, shareable code used by guests to join the party without authentication."
        },
        "partyType": {
          "type": "string",
          "description": "The type or theme of the party (e.g., 'Birthday', 'Graduation', 'Casual Gathering'), used for AI activity suggestions."
        },
        "guestAgeRange": {
          "type": "string",
          "description": "The general age range of guests expected at the party (e.g., 'All Ages', 'Adults Only', 'Teens'), used for AI activity suggestions."
        },
        "hostPreferences": {
          "type": "string",
          "description": "Specific preferences or interests of the host that can guide AI activity suggestions (e.g., 'Board Games', 'Live Music', 'Karaoke')."
        },
        "createdAt": {
          "type": "string",
          "description": "The timestamp when the party was created.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "name",
        "dateTime",
        "ownerId",
        "inviteCode",
        "createdAt"
      ]
    },
    "Participant": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Participant",
      "type": "object",
      "description": "Represents a guest who has joined a specific party. Since there is no authentication, participants are identified by a display name within the context of a party.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Participant entity."
        },
        "partyId": {
          "type": "string",
          "description": "Reference to the Party this participant has joined. (Relationship: Party 1:N Participant)"
        },
        "displayName": {
          "type": "string",
          "description": "The name chosen by the guest to be displayed in the party chat and participant list."
        },
        "joinTime": {
          "type": "string",
          "description": "The timestamp when the participant joined the party.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "partyId",
        "displayName",
        "joinTime"
      ]
    },
    "ChatMessage": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ChatMessage",
      "type": "object",
      "description": "Represents a single chat message sent within a party's real-time chat.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the ChatMessage entity."
        },
        "partyId": {
          "type": "string",
          "description": "Reference to the Party where this message was sent. (Relationship: Party 1:N ChatMessage)"
        },
        "senderId": {
          "type": "string",
          "description": "Reference to the Participant who sent this message. (Relationship: Participant 1:N ChatMessage)"
        },
        "content": {
          "type": "string",
          "description": "The actual text content of the chat message."
        },
        "timestamp": {
          "type": "string",
          "description": "The timestamp indicating when the message was sent.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "partyId",
        "senderId",
        "content",
        "timestamp"
      ]
    },
    "ActivitySuggestion": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ActivitySuggestion",
      "type": "object",
      "description": "Represents an activity suggestion, potentially generated by AI, for a specific party.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the ActivitySuggestion entity."
        },
        "partyId": {
          "type": "string",
          "description": "Reference to the Party for which this activity is suggested. (Relationship: Party 1:N ActivitySuggestion)"
        },
        "suggestionText": {
          "type": "string",
          "description": "The description of the suggested activity."
        },
        "category": {
          "type": "string",
          "description": "The category of the suggestion (e.g., 'Game', 'Music', 'Food', 'Decor')."
        },
        "suggestedByAI": {
          "type": "boolean",
          "description": "Indicates whether the suggestion was generated by the AI tool."
        },
        "timestamp": {
          "type": "string",
          "description": "The timestamp when this suggestion was made or stored.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "partyId",
        "suggestionText",
        "suggestedByAI",
        "timestamp"
      ]
    }
  },
  "auth": {
    "providers": [
      "password",
      "anonymous"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/parties/{partyId}",
        "definition": {
          "entityName": "Party",
          "schema": {
            "$ref": "#/backend/entities/Party"
          },
          "description": "Top-level collection storing details of each party event. Each document includes the 'ownerId' (the host's UID) for authorization independence. The 'inviteCode' is used for guest access, validated by a backend service before participant creation.",
          "params": [
            {
              "name": "partyId",
              "description": "The unique identifier for the Party."
            }
          ]
        }
      },
      {
        "path": "/parties/{partyId}/participants/{participantId}",
        "definition": {
          "entityName": "Participant",
          "schema": {
            "$ref": "#/backend/entities/Participant"
          },
          "description": "Subcollection storing details of each guest who has joined a specific party. The 'participantId' is set to the guest's anonymous Firebase Authentication UID, which serves as their unique identifier within the party scope. Membership is verified by the existence of this document for a given UID and partyId. Denormalizes 'partyId' via the path.",
          "params": [
            {
              "name": "partyId",
              "description": "The unique identifier of the parent Party."
            },
            {
              "name": "participantId",
              "description": "The unique identifier for the Participant, corresponding to their anonymous Firebase Auth UID."
            }
          ]
        }
      },
      {
        "path": "/parties/{partyId}/chatMessages/{chatMessageId}",
        "definition": {
          "entityName": "ChatMessage",
          "schema": {
            "$ref": "#/backend/entities/ChatMessage"
          },
          "description": "Subcollection storing individual chat messages for a specific party. Each message includes 'senderId' (the participant's UID) for explicit message ownership and authorization. Denormalizes 'partyId' via the path.",
          "params": [
            {
              "name": "partyId",
              "description": "The unique identifier of the parent Party."
            },
            {
              "name": "chatMessageId",
              "description": "The unique identifier for the ChatMessage."
            }
          ]
        }
      },
      {
        "path": "/parties/{partyId}/activitySuggestions/{activitySuggestionId}",
        "definition": {
          "entityName": "ActivitySuggestion",
          "schema": {
            "$ref": "#/backend/entities/ActivitySuggestion"
          },
          "description": "Subcollection storing AI-generated or host-created activity suggestions for a specific party. Denormalizes 'partyId' via the path.",
          "params": [
            {
              "name": "partyId",
              "description": "The unique identifier of the parent Party."
            },
            {
              "name": "activitySuggestionId",
              "description": "The unique identifier for the ActivitySuggestion."
            }
          ]
        }
      }
    ],
    "reasoning": "The proposed Firestore structure for BashConnect prioritizes security, scalability, and debuggability by strictly adhering to the core design principles, especially Authorization Independence and Structural Segregation.\n\n**Authorization Independence via Denormalization:**\n\n1.  **Party Ownership:** Each `Party` document includes an `ownerId` field, storing the `uid` of the host who created the party. This denormalization allows rules to check `request.auth.uid == resource.data.ownerId` directly on the `Party` document without requiring any `get()` calls to parent collections. This is critical for atomic operations and simplifies rule debugging.\n2.  **Participant Membership:** For subcollections like `participants`, `chatMessages`, and `activitySuggestions`, membership to the parent `Party` is verified by checking the existence of a `Participant` document at `parties/{partyId}/participants/$(request.auth.uid)`. This `exists()` check is a robust and performant way to confirm membership without reading data from the parent document's fields, thus avoiding `get()` for authorization logic within rules. The `participantId` itself is set to `request.auth.uid` (obtained via anonymous authentication), further simplifying identity checks.\n3.  **Contextual IDs:** All subcollection documents (Participant, ChatMessage, ActivitySuggestion) inherently denormalize the `partyId` through their hierarchical path (`/parties/{partyId}/...`). `ChatMessage` documents also explicitly store `senderId` (the participant's `uid`) for clear message ownership and simple rule checks.\n4.  **Invite Code Handling:** To strictly avoid `get()` calls in security rules for `inviteCode` validation, the process of a guest joining a party (i.e., creating a `Participant` document) is designed to be mediated by a trusted backend service (e.g., a Cloud Function). This function would validate the `inviteCode` against the `Party` document off-band, and only then create the `Participant` document. Firestore rules would then simply verify that `request.auth.uid` matches the `participantId` being created.\n\n**QAPs (Rules are not Filters) Support:**\n\nThis structure strongly supports QAPs by ensuring all `list` operations are implicitly or explicitly scoped:\n\n*   **Listing Parties:** Hosts can list their own parties by querying the top-level `/parties` collection with `where('ownerId', '==', request.auth.uid)`. This is a QAP-compliant query, as the rule can verify `resource.data.ownerId == request.auth.uid` for each document returned.\n*   **Listing Subcollection Data (Participants, ChatMessages, ActivitySuggestions):** All `list` operations on subcollections are always scoped to a specific `{partyId}`. For example, to list chat messages, a client must query `/parties/{partyId}/chatMessages`. The security rules for these subcollections then verify that the `request.auth.uid` is either the party's `ownerId` or an `exists()`ing `participant` within that specific `{partyId}`. This ensures that clients cannot perform broad, unindexed `list` operations that bypass security. The structural segregation of data by `partyId` is key to this QAP compliance."
  }
}